<!-- 
/*
 * 
 *                  xxxxxxx      xxxxxxx
 *                   x:::::x    x:::::x 
 *                    x:::::x  x:::::x  
 *                     x:::::xx:::::x   
 *                      x::::::::::x    
 *                       x::::::::x     
 *                       x::::::::x     
 *                      x::::::::::x    
 *                     x:::::xx:::::x   
 *                    x:::::x  x:::::x  
 *                   x:::::x    x:::::x 
 *              THE xxxxxxx      xxxxxxx TOOLKIT
 *                    
 *                  http://www.goXTK.com
 *                   
 * Copyright (c) 2012 The X Toolkit Developers <dev@goXTK.com>
 *                   
 *    The X Toolkit (XTK) is licensed under the MIT License:
 *      http://www.opensource.org/licenses/mit-license.php
 *
 *
 * SLICE DANCE!!
 *
 */
-->

<html>
<head>
<title>SLICE DANCE</title>

<!-- <script type="text/javascript" src="../xtk.js"></script> -->
<script type="text/javascript" src="../../X/lib/closure-library/closure/goog/base.js"></script>
<script type="text/javascript" src="../../X/xtk-deps.js"></script>
<script type="text/javascript"
	src="http://get.goXTK.com/xtk_xdat.gui.js"></script>

<script type="text/javascript">
  goog.require('X.renderer3D');
  goog.require('X.renderer2D');
  goog.require('X.volume');
  
  var run = function() {

    _webGLFriendly = true;
    try {
      threeD = new X.renderer3D();
      threeD.container = '3d';
      threeD.init();
    } catch (Exception) {
      
      // no webgl on this machine
      _webGLFriendly = false;
      
    }
    
    sliceX = new X.renderer2D('X');
    sliceX.container = 'sliceX';
    sliceX.init();
    var sliceY = new X.renderer2D('Y');
    sliceY.container = 'sliceY';
    sliceY.init();
    var sliceZ = new X.renderer2D('Z');
    sliceZ.container = 'sliceZ';
    sliceZ.init();
    
    volume = new X.volume();
    volume.file = 'vol.nrrd';
    volume.labelmap.file = 'seg.nrrd';
    volume.labelmap.colortable.file = 'genericanatomy.txt'; // the 3D Slicer generic anatomy color table
    volume.caption = 'dfsdfd';
    
    sliceX.add(volume);
    sliceX.render();
    
    sliceX.onScroll = function() {

      if (_webGLFriendly) {
        volume.modified();
        threeD.render();
      }
      
    }
    sliceY.onScroll = function() {

      if (_webGLFriendly) {
        volume.modified();
        threeD.render();
      }
      
    }
    sliceZ.onScroll = function() {

      if (_webGLFriendly) {
        volume.modified();
        threeD.render();
      }
      
    }


    sliceX.onShowtime = function() {

      // clear the showtime function
      sliceX.onShowtime = function() {

      }


      sliceY.add(volume);
      sliceY.render();
      sliceZ.add(volume);
      sliceZ.render();
      threeD.add(volume);
      threeD.render();
      
      //
      // The GUI panel
      //
      // (we need to create this during onShowtime(..) since we do not know the volume
      // dimensions before the loading was completed)
      
      var modelWasLoaded = false;
      
      var gui = new dat.GUI();
      var volumegui = gui.addFolder('Volume');
      // ,, switch between slicing and volume rendering
      var vrController = volumegui.add(volume, 'volumeRendering');
      // .. configure the volume rendering opacity
      var opacityController = volumegui.add(volume, 'opacity', 0, 1);
      // .. we can threshold
      var lowerThresholdController = volumegui.add(volume, 'lowerThreshold',
          volume.min, volume.max);
      var upperThresholdController = volumegui.add(volume, 'upperThreshold',
          volume.min, volume.max);
      var sliceXController = volumegui.add(volume, 'indexX', 0,
          volume.dimensions[0] - 1).listen();
      var sliceYController = volumegui.add(volume, 'indexY', 0,
          volume.dimensions[1] - 1).listen();
      var sliceZController = volumegui.add(volume, 'indexZ', 0,
          volume.dimensions[2] - 1).listen();
      volumegui.open();
      
      var labelmapgui = gui.addFolder('Label Map');
      var labelMapVisibleController = labelmapgui.add(volume.labelmap,
          'visible');
      var labelMapOpacityController = labelmapgui.add(volume.labelmap,
          'opacity', 0, 1);
      labelmapgui.open();
      

      // volumegui callbacks
      vrController.onChange(function(value) {

        // this setting makes the volume rendering look good
        volume.opacity = 0.15;
        
        // Iterate over the gui controllers to grab updated values
        for ( var i in volumegui.__controllers) {
          volumegui.__controllers[i].updateDisplay();
        }
        
        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
      });
      opacityController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
      });
      
      lowerThresholdController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
      upperThresholdController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
      sliceXController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
      sliceYController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
      sliceZController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
      
      // labelmapgui callbacks
      labelMapVisibleController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
      labelMapOpacityController.onChange(function(value) {

        volume.modified();
        if (_webGLFriendly) {
          threeD.render();
        }
        sliceX.render();
        sliceY.render();
        sliceZ.render();
      });
     
      
    };
    


  };
</script>
<body onload="run()" style="margin: 0px; background-color: #000">

	<!-- the container for the renderer -->
	<div id="3d"
		style="background-color: #000; width: 100%; height: 69%; margin-bottom: 2px;"></div>
	<div id="sliceX"
		style="border-style: solid; border-color: yellow; background-color: #000; width: 32%; height: 30%; float: left;"></div>
	<div id="sliceY"
		style="border-style: solid; border-color: red; background-color: #000; width: 32%; height: 30%; float: left;"></div>
	<div id="sliceZ"
		style="border-style: solid; border-color: green; background-color: #000; width: 32%; height: 30%; float: left;"></div>

</body>